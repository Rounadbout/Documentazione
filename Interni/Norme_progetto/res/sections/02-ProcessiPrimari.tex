\section{Processi Primari}
    \subsection{Fornitura}
        \subsubsection{Descrizione}
        Il processo di fornitura ha lo scopo di determinare l'insieme delle attività necessarie allo svolgimento del progetto. %Tale processo è composto dalle seguenti attività:
       % \begin{itemize}
           % \item{avvio;}
            %\item{preparazione di risposta alle richieste;}
           % \item{contrattazione;}
            %\item{pianificazione;}
            %\item{esecuzione e controllo;}
           % \item{revisione e valutazione;}
            %\item{consegna e completamento;}
        %\end{itemize}
         In questa sezione vengono esposte le regole che i membri del team \Gruppo{} si impegnano a rispettare nel corso delle fasi di progettazione, sviluppo e consegna della piattaforma \NomeProgetto{}, per diventare fornitori nei confronti del Proponente \Proponente{} e dei Committenti \TV{} e \RC{}. \\
         L'obiettivo del gruppo è quello di mantenere un costante dialogo con il Proponente\ped{\textit{G}} al fine di:
         \begin{itemize}
		\item{instaurare un rapporto di collaborazione;} 
		\item{comprenderne a fondo le richieste;}
		\item{determinare vincoli sui processi e sui requisiti;}
		\item{stimare i costi;}
		\item{promuovere una verifica continua;}
		\item{avere un riscontro efficace sul lavoro svolto.}
         \end{itemize}
        
        \subsubsection{Attività}
        \subsubsubsection{Studio di Fattibilità}
        Lo \SdF{} viene redatto dagli Analisti ed indica il risultato dell'attività di valutazione di ogni capitolato\ped{\textit{G}} proposto. Tra le informazioni da esso fornite, sono presenti:
        \begin{itemize}
            \item{\textbf{Informazioni generali}: presentano il nome del progetto, del Proponente\ped{\textit{G}} e del Committente\ped{\textit{G}};}
            \item{\textbf{Descrizione}: descrive sinteticamente il capitolato\ped{\textit{G}} sotto analisi;}
            \item{\textbf{Obiettivo finale}: rappresenta il prodotto\ped{\textit{G}} risultante dal completamento del progetto, con soddisfacimento dei requisiti;}
            \item{\textbf{Tecnologie coinvolte}: descrive le tecnologie necessarie al raggiungimento dell'obiettivo finale;}
            \item{\textbf{Aspetti positivi}: espongono gli elementi del capitolato\ped{\textit{G}} che hanno suscitato entusiasmo nel team;}
            \item{\textbf{Criticità}: analizza i punti critici ed i fattori di rischio relativi alla realizzazione del progetto;}
            \item{\textbf{Esito}: illustra la posizione finale del team nei confronti del capitolato\ped{\textit{G}}.}
        \end{itemize}
        
        \subsubsubsection{Piano di Progetto}
        Il Responsabile di Progetto, con l'aiuto degli Amministratori, redige un \PdP{} volto a pianificare le attività del team. Tale documento contiene:
        \begin{itemize}
        		\item{\textit{Mancano riferimenti}}
        \end{itemize}
        
        \subsubsubsection{Piano di Qualifica}
        I Progettisti ed i Verificatori redigono il \PdQ{}, il cui scopo è raccogliere le metriche e le strategie impiegate per garantire la qualità sia dei processi attuati che del prodotto\ped{\textit{G}}, nel tempo. Tale documento contiene:
        \begin{itemize}
        		\item{\textit{Mancano riferimenti}}
        \end{itemize}
        
        \subsubsection{Strumenti}
        Di seguito vengono elencati gli strumenti usati durante il processo di fornitura:
        
	\subsection{Sviluppo}
		\subsubsection{Descrizione}
		Il processo di sviluppo contiene le attività ed i compiti che devono essere svolti per produrre il software richiesto. Esso viene svolto in conformità allo standard ISO/IEC 12207:1995, comprendendo perciò le seguenti attività:
		\begin{itemize}
			\item{Analisi dei Requisiti;}
			\item{Progettazione;}
			\item{Codifica.}
		\end{itemize}
		
		In particolare, l'obiettivo del team è quello di sviluppare un prodotto\ped{\textit{G}} software che superi i test, soddisfi le richieste ed i requisiti, fissati dal Proponente\ped{\textit{G}}.
        
        \subsubsection{Attività}
            \subsubsubsection{Analisi dei Requisiti}
           	Nell'\AdR{} gli Analisti individuano ed elencano tutti i requisiti richiesti dal Proponente\ped{\textit{G}} per il progetto in questione. Tali requisiti possono derivare da:
	        \begin{itemize}
	           		\item{capitolato\ped{\textit{G}} d'appalto;}
					\item{verbali di riunioni interne o esterne;}
					\item{casi d'uso.}
	    	\end{itemize}
           	
           	E sono fondamentali per:
            \begin{itemize}
        		\item{descrivere lo scopo del lavoro;}
				\item{fornire ai Progettisti riferimenti specifici ed affidabili;}
				\item{fissare funzionalità concordate con il cliente;}
				\item{fornire una base per raffinamenti successivi al fine di garantire un miglioramento continuo;}
				\item{facilitare le revisioni del codice;}
				\item{stimare i costi in base alla quantità di lavoro prevista.}
        	\end{itemize}                 
             
            \subsubsubsection*{Casi d'uso}
			Dopo aver identificato i casi d'uso\ped{\textit{G}}, compito degli Analisti è quello di elencarli con un grado di precisione che va dal generale al particolare, usando la struttura:
			\begin{itemize}
		    	\item{\textbf{codice identificativo}}; 
		    	\item{\textbf{titolo}}; 
		    	\item{\textbf{diagramma UML}}; 
		    	\item{\textbf{attori primari}}; 
		    	\item{\textbf{attori secondari}}; 
		    	\item{\textbf{descrizione}}; 
		    	\item{\textbf{scenario principale}}; 
	    		\item{\textbf{specializzazioni (se presenti)}}; 
		    	\item{\textbf{inclusioni (se presenti)}}; 
		    	\item{\textbf{estensioni (se presenti)}}; 
		    	\item{\textbf{precondizione}};
		    	\item{\textbf{postcondizione}}. 
			\end{itemize}
			
			\noindent Ogni caso d'uso dev'essere corredato da un codice identificativo, che segue la dicitura: 
			\begin{center}
				\textbf{UC[codice\_padre].[codice\_figlio]}
			\end{center}
			
			\noindent Dove:
			\begin{itemize}
	         	\item{\textbf{Codice padre}: numero che identifica univocamente i casi d'uso generici;}
	         	\item{\textbf{Codice figlio}: numero progressivo che identifica i sottocasi. Può a sua volta includere altri livelli.}
			\end{itemize}
             
            \subsubsubsection*{Requisiti}   
			Ogni requisito emerso durante l'attività di analisi dev'essere descritto dalla seguente struttura:
            	\begin{itemize}
                   	\item{codice identificativo;}
                   	\item{fonti;} 
                   	\item{relazioni di dipendenza con altri requisiti;}
                   	\item{descrizione;}
                   	\item{importanza.}
     			\end{itemize}
		                 
            	\noindent Ogni requisito dev'essere corredato da un codice identificativo, che segue la dicitura: 
				\begin{center}
					\textbf{R[Importanza][Tipologia][Codice]}
				\end{center}
			
				Dove:
				\begin{itemize}
				   	\item{\textbf{Importanza}: indica il grado di importanza del requisito ai fini del progetto. Può assumere i valori:}
				   	\begin{itemize}
				           	\item{\textbf{1}: requisito obbligatorio ai fini del progetto, irrinunciabile per gli stakeholders;}
				           	\item{\textbf{2}: requisito desiderabile: non strettamente necessario ai fini del progetto ma che porta valore aggiunto;}
				           	\item{\textbf{3}: requisito opzionale, contrattabile più avanti nel progetto.}
				   	\end{itemize}
				   	
				   	\item{\textbf{Tipologia}: classe a cui appartiene il requisito in questione. Può assumere i valori:}
				   	\begin{itemize}
				   		\item{\textbf{F}: funzionale;}
				   		\item{\textbf{P}: prestazionale;}
				   		\item{\textbf{Q}: qualitativo;}
				   		\item{\textbf{V}: vincolo.}
				   	\end{itemize}
				   	
				   	\item{\textbf{Codice}: identificatore univoco del requisito}.
				\end{itemize}
	            \noindent Il codice stabilito secondo la convenzione precedente, una volta associato ad un requisito, non può più essere modificato. \\
  
                \noindent Inoltre per ogni requisito bisogna indicare: 
                \begin{itemize}
                	\item{\textbf{descrizione}}: breve descrizione del requisito, strutturata in maniera da evitare ambiguità; 
                	
                	\item{\textbf{classificazione}}: indica il grado di importanza del requisito considerato. Sebbene tale informazione sia già presente nell'identificativo, la sua ripetizione rende la lettura più semplice e scorrevole;	
                	
                	\item{\textbf{fonti}}:   
                	\begin{itemize}
                		\item \textit{capitolato}: requisito indicato nel capitolato; 
                		\item \textit{interno}: requisito individuato dagli analisti; 
                		\item \textit{caso d'uso}: il requisito è stato estrapolato da uno o più casi d'uso. In questo caso vengono riportati gli identificativi dei casi d'uso considerati; 
                		\item \textit{verbale}: si tratta di un requisito individuato a seguito di un incontro tra i membri del gruppo o di una richiesta di chiarimento con il proponente. 
                		In questo caso è riportato il codice identificativo presente nella tabella delle decisioni dei verbali considerati. 
                	\end{itemize} 
                \end{itemize} 
                         
            \subsubsection*{Diagrammi UML}
            I diagrammi UML\ped{\textit{G}} devono essere realizzati utilizzando la versione del linguaggio \textit{v2.0}.
            Per garantire leggibilità è richiesto che gli Analisti si occupino di creare i diagrammi UML 
            rispettando le seguenti indicazioni: 
            \begin{itemize}
            	\item distribuire in modo omogeneo gli elementi all'interno dello spazio disponibile, mantenendo un margine minimo; 
            	\item dove possibile, allineare i vari elementi sia in senso verticale sia in orizzontale; 
            	\item impostare i collegamenti in uscita da ogni elemento ad angolo retto.  
            \end{itemize}
            
                         
        \subsubsubsection{Progettazione}
            L'attività di progettazione definisce una soluzione del problema presentato, soddisfacente per tutti gli stakeholders, in relazione ai requisiti specificati nel documento \AdR{}. Questo garantisce che il prodotto\ped{\textit{G}} sviluppato soddisfi le proprietà e i bisogni specificati dal Proponente\ped{\textit{G}}. 
            La progettazione ha quindi come obiettivo l'elaborazione di una struttura adeguata per il sistema, poi descritta nei seguenti documenti:
            \begin{itemize}
            	\item{\textbf{\TB{}}\ped{\textit{G}}: contiene le specifiche della progettazione ad alto livello, i diagrammi UML\ped{\textit{G}} utilizzati per la realizzazione dell'architettura ed i test di verifica;}
				\item{\textbf{\PB{}}\ped{\textit{G}}: approfondisce l'attività di progettazione precedentemente trattata nella Technology Baseline\ped{\textit{G}}, specifica le definizioni delle classi e definisce i test necessari alla verifica.}
    		\end{itemize}
	     
	     \subsubsubsection*{Technology Baseline}
	     Tale documento viene redatto dal Progettista e contiene:
	     \begin{itemize}
    	 	\item{\textbf{Diagrammi UML\ped{\textit{G}}}}: usati per rendere più chiare le scelte progettuali adottate e ridurre le ambiguità. Possono essere:
        		\begin{itemize}
                	\item{diagrammi di attività}: descrivono la logica procedurale di un flusso di operazioni, aiutando a descrivere gli aspetti dinamici dei casi d'uso; 
	    			\item{diagrammi delle classi:} descrivono le classi presenti all'interno del sistema, soffermandosi sui loro metodi, attributi e relazioni ; 
	    			\item{diagrammi dei package}: descrivono le relazioni di dipendenza presenti tra classi raggruppate in package diversi, ossia in raggruppamenti di un numero arbitrario di elementi in unità di livelllo più alto;  			
					\item{diagrammi di sequenza}: descrivono la collaborazione di un gruppo di oggetti che devono implementare collettivamente un comportamento;                  
				\end{itemize}
				
			\item \textbf{Design pattern}\ped{\textit{G}}: vengono esplicitati chiaramente i design pattern\ped{\textit{G}} utilizzati per l'architettura, accompagnandoli con una descrizione ed un diagramma, così da esporne il significato e la struttura; 
			\item \textbf{Tracciamento delle componenti}: viene rappresentata la relazione tra ogni requisito ed il componente che lo soddisfa. Dimostrando quindi concretamente la loro completa esaustione;
			\item \textbf{Test di integrazione}: vengono definite delle classi di verifica, per accertarsi che ogni componente del sistema funzioni come previsto.
	     \end{itemize}
	     
	     \subsubsubsection*{Product Baseline}
	     Tale documento viene redatto dal Progettista e contiene:
	     \begin{itemize}
	     	\item \textbf{Diagrammi UML}\ped{\textit{G}}:
				\begin{itemize}
					\item{diagrammi di attività;}
    				\item{diagrammi delle classi;}
					\item{diagrammi di sequenza.}
				\end{itemize}
			\item \textbf{Definizione delle classi}: ogni classe viene descritta illustrandone lo scopo e le funzionalità;
			\item \textbf{Tracciamento delle classi}: ogni requisito viene tracciato, in modo da garantire che ogni classe ne soddisfi almeno uno; 
			\item \textbf{Test di unità}: vengono definiti dei test di unità per verificare che le componenti del sistema funzionino come previsto. 
	     \end{itemize}
     
     	\subsubsection*{Diagrammi delle classi}
     	I diagrammi delle classi devono descrivere le tipologie di oggetti presenti all'interno del sistema e le relazioni di dipendenza tra essi presenti. 
     	Ogni classe viene rappresentata tramite un rettangolo tripartito in senso orizzontale, 
     	che conterrà rispettivamente: 
     	\begin{enumerate}
     		\item{\textbf{nome della classe}}: che deve essere univoco, scritto con la lettera maiuscola e in inglese. Nel caso in cui la classe sia astratta, il nome deve essere scritto in italico; nel caso in cui si tratti invece di un'interfaccia, il nome dovrà essere preceduto dal termine \texttt{<<interface>>}; 
     		
     		\item{\textbf{attributi (opzionali)}}: rappresentano lo stato interno della classe. Ogni attributo deve essere indicato nel seguente modo: 
     		\begin{center}
     			\textbf{visibilità nome : tipo [molteplicità] = default \{proprietà aggiuntive\}}
     		\end{center}
     		dove:
     			\begin{itemize}
     				\item{\textbf{visibilità}}: visibilità dell'attributo rispetto all'esterno della classe, può essere pubblica, protetta o privata; 
     				\item{\textbf{nome}}: nome dell'attributo; 
   					\item{\textbf{tipo}}: tipo dell'attributo;
					\item{\textbf{molteplicità (opzionale)}}: numero di occorrenze dell'attributo all'interno della classe;
					\item{\textbf{default(opzionale)}}: eventuale valore predefinito dell'attributo;  
					\item{\textbf{proprietà aggiuntive}}: eventuali informazioni aggiuntive relative all'attributo considerato; 
     			\end{itemize}
     		
     		\item{\textbf{operazioni (opzionali)}}: rappresentano le azioni che la classe è in grado di compiere. Ogni operazione deve essere indicata nel seguente modo: 
     			\begin{center}
     				\textbf{visibilità nome (lista-parametri) : tipo-ritorno \{proprietà aggiuntive\}}
     			\end{center}
     		dove: 
     			\begin{itemize}
     				\item{\textbf{visibilità}}: visibilità dell'operazione rispetto all'esterno della classe, può essere pubblica, protetta o privata; 
     				\item{\textbf{nome}}: nome dell'operazione; 
     				\item{\textbf{lista-parametri}}: lista di parametri dell'operazione; per ogni parametro dovranno essere indicate le seguenti proprietà: 
	     				\begin{itemize}
	     					\item{\textbf{direzione (opzionale)}}: modalità di accesso al parametro, può essere in lettura, in scrittura o entrambe; di default è in lettura;  
	     					\item{\textbf{nome}}: nome del parametro; 
	     					\item{\textbf{tipo}}: tipo del parametro; 
	     					\item{\textbf{default (opzionale)}}: eventuale valore di default del parametro; 	
	     				\end{itemize} 
     				\item{\textbf{tipo-ritorno}}: tipo di ritorno della funzione considerata;       					
					\item{\textbf{proprietà aggiuntive(opzionali)}}: eventuali informazioni aggiuntive relative alla funzione; 
     			\end{itemize}
     	\end{enumerate}
     	Le varie classi possono essere collegate tra di loro tramite apposite frecce, che esplicitano le relazioni di dipendenza presenti tra esse. In particolare, i gradi di dipendenza considerati sono: 
     	\begin{itemize}
     		\item{\textbf{dipendenza}}: indicata con la freccia tratteggiata, si ha quando la classe utilizza un oggetto della classe con cui si relaziona;
     		\item{\textbf{aggregazione}}: indicata con la freccia "a diamante" vuota, si ha quando la classe considerata presenta come attributo almeno un riferimento alla classe con cui si relaziona;
     		\item{\textbf{composizione}}: indicata con la freccia "a diamante" piena, si ha quando la classe contiene come attributo almeno un oggetto della classe con cui si relaziona;
     		\item{\textbf{associazione}}: indicata con una linea semplice, si ha quando la classe crea e utilizza un oggetto della classe con cui si relaziona;
     		\item{\textbf{generalizzazione}}: indicata con la freccia vuota, viene usata per indicare relazioni di tipo "Is-A". 
     	\end{itemize}
     	      	
     	\subsubsection*{Diagrammi dei package}
     	Ogni package deve essere rappresentato tramite un rettangolo con un'etichetta per il nome, che dovrà essere in inglese e scritto in minuscolo. Ogni package può contenere al suo interno altri package o classi. \\
     	Le dipendenze tra package devono essere indicate con frecce tratteggiate che dovrebbero seguire tutte le medesima direzione, in modo da evitare la creazione di dipendenze cicliche. 
     	
     	\subsubsection*{Diagrammi di attività}
     	I diagrammi di attività permettono di descrivere i processi che compongono l'applicazione software attraverso dei grafi in cui i nodi rappresentano le azioni e gli archi l'ordine in cui esse sono eseguite.
     	Gli elementi usati in tali diagrammi sono i seguenti: 
     	\begin{itemize}
     		\item{\textbf{nodo iniziale}}: rappresentato da un pallino pieno, porta alla generazione di un token ed è il punto d'inizio dell'esecuzione dell'attività; 
     		\item{\textbf{activity}}: rappresenta un'azione all'interno dell'attività, viene indicata  da un rettangolo che ne contiene la descrizione; 
     		\item{\textbf{subactivity}}: è rappresentata da un rettangolo che ne contiene il nome, viene usata per riferirsi ad una sottoattività il cui diagramma deve essere fornito separatamente; 
     		\item{\textbf{branch}}: tali nodi modellano delle decisioni, vengono indicati tramite dei rombi vuoti e generalmente distinguono due branch. Il test che deve essere soddisfatto normalmente viene indicato da un'etichetta posta di fianco al nodo di branch; 
     		\item{\textbf{merge}}: punto in cui i rami generati da un branch si uniscono, vengono rappresentati nello stesso modo dei nodi di branch; 
     		\item{\textbf{fork}}: punto in cui l'attività si parallelizza senza vincoli di esecuzione temporale, viene indicato da una lunga linea orizzontale o verticale. Consuma un token e ne genera uno per ogni percorso in uscita;  
     		\item{\textbf{join}}: rappresentato allo stesso modo del fork, è un punto in cui avviene la sincronizzazione di processi paralleli. Consuma un token per ogni percorso in entrata e genera un solo token; 
     		\item{\textbf{pin}}: rappresentato da un quadratino da cui entrano o escono frecce, indica la produzione o consumo di un parametro, il cui tipo va indicato di fianco;
     		\item{\textbf{segnali}}: vengono rappresentati tramite due figure "a incastro", la prima (non bloccante) per l'emissione del segnale, la seconda (bloccante) per la ricezione dello stesso. Rappresenta un evento esterno;
     		\item{\textbf{timeout}}: sono rappresentati da una clessidra, permettono di modellare timeout ed eventi ripetuti;
     		\item{\textbf{nodo di fine flusso}}: rappresentato da un cerchio vuoto con una X al centro. Porta al consumo di un token e rappresenta un punto di terminazione di un percorso di esecuzione; non causa la terminazione dell'esecuzione dell'attività; 
     		\item{\textbf{nodo finale}}: viene rappresentato da due cerchi concentrici: il più esterno vuoto e il più interno pieno. Porta al consumo di un token e rappresenta il punto di terminazione dell'esecuzione dell'attività. 
     	\end{itemize}
     	
     	\subsubsection*{Diagrammi di sequenza}
     	I diagrammi di sequenza permettono di descrivere la collaborazione di un gruppo di oggetti che devono implementare collettivamente un comportamento. \\
     	Tali diagrammi devono essere letti verticalmente, dall'alto al basso, in modo da simulare lo scorrere del tempo. Ognuno degli oggetti coinvolti viene indicato tramite un rettangolo, che contiene il nome a lui associato. \\  
     	All'interno del diagramma è consigliato l'utilizzo delle barre di attivazione, in modo da rendere immediatamente visibile a chi osserva lo stato di attività del diagramma. 	\\ 
     	La collaborazione tra gli oggetti rappresentati è resa possibile tramite lo scambio di messaggi, che viene indicato da apposite frecce. Un messaggio può essere di una delle seguenti tipologie: 
     	\begin{itemize}
     		\item{\textbf{messaggio sincrono}}: viene indicato tramite una freccia piena, corrisponde alla chiamata sincrona di un metodo. Il chiamante deve attendere la risposta del chiamato prima di continuare l'esecuzione;
     		\item{\textbf{messaggio asincrono}}: viene indicato tramite una freccia, corrisponde ad una chiamata asincrona. Il chiamante non deve aspettare la risposta del chiamato per continuare l'esecuzione;
     		\item{\textbf{messaggio di ritorno}}: indicato con una freccia tratteggiata, rappresenta il ritorno di un metodo chiamato; 
     		\item{\textbf{messaggio di creazione}}: indicato con una freccia tratteggiata sormonata da \texttt{<<create>>}, rappresenta la creazione di un nuovo oggetto;
     		\item{\textbf{messaggio di distruzione}}: freccia piena sormontata da \texttt{<<destroy>>}, indica la distruzione di un oggetto.
     	\end{itemize}
     
     	Per modellare in maniera più dettagliata le interazioni tra gli oggetti si consiglia l'utilizzo dei frame d'interazione. Ognuno di tali frame è caratterizzato dalle seguenti proprietà: 
     	\begin{itemize}
     		\item{\textbf{guardia}}: indica la condizione di attivazione del frame; 
     		\item{\textbf{etichetta}}: viene usata per indicare la tipologia del frame d'interazione considerato. Le tipologie possibili sono: 
     		\begin{itemize}
     			\item{\textbf{alt}}: rappresenta un'alternativa tra più frame; viene eseguito solo quello per cui si verifica la condizione;
     			\item{\textbf{opt}}: rappresenta l'esecuzione opzionale di un frame, che avviene solo se la condizione specificata si verifica;
     			\item{\textbf{par}}: indica frammenti da eseguire in parallelo;
     			\item{\textbf{loop}}: indica che il frammento può essere eseguito più volte, la base dell'iterazione è indicata dalla guardia;
     			\item{\textbf{region}}: rappresenta una regione critica, il frammento può essere eseguito da un solo thread alla volta;
     			\item{\textbf{neg}}: indica un'iterazione non valida;
     			\item{\textbf{ref}}: si riferisce ad un'interazione definita in un altro diagramma;  
     			\item{\textbf{sd}}: utilizzato per racchiudere un intero diagramma di sequenza.
     		\end{itemize} 
     	\end{itemize}
     
     	\subsubsubsection*{Qualità dell'architettura}
     	In seguito alla definizione dei requisiti, che consolida le funzionalità richieste, ci si occupa della realizzazione dell'architettura del sistema. Tale architettura dovrà godere delle seguenti proprietà: 
     	\begin{itemize}
     		\item{\textbf{sufficienza}}: deve soddisfare i requisiti definiti nel documento \AdR; 
     		\item{\textbf{comprensibilità}}: deve essere capibile da tutti gli stakeholder; 
     		\item{\textbf{modularità}}: deve essere suddivisa in parti chiare e ben distinte; 
     		\item{\textbf{robustezza}}: deve essere in grado di sopportare ingressi diversi, sia da parte dell'utente che dell'ambiente; 
     		\item{\textbf{flessibilità}}: deve permettere di essere modificata senza sostanziali modifiche e a costi contenuti al variare dei requisiti; 
     		\item{\textbf{efficienza}}: deve gestire le risorse in maniera da ridurre eventuali sprechi; 
     		\item{\textbf{affidabilità}}: l'architettura deve garantire una buona usabilità del prodotto una volta implementata; 
     		\item{\textbf{disponibilità}}: la manutenzione delle sue parti deve richiedere un tempo limitato e non andare ad affliggere il corretto funzionamento di tutto il sistema;
     		\item{\textbf{sicurezza}}: non deve presentare gravi malfunzionamenti o essere vulnerabile ad intrusioni; 
     		\item{\textbf{semplicità}}: ogni sua parte deve contenere solo il necessario e nulla di superfluo; 
     		\item{\textbf{incapsulazione}}: costituita da componenti le cui informazioni interne non sono visibii da fuori;
     		\item{\textbf{coesione}}: composta in maniera che le parti con obiettivo comune siano raggruppate insieme; 
     		\item{\textbf{basso accoppiamento}}: composta da parti distinte che devono essere indipendenti tra di loro, in modo che l'architettura possa subire modifiche a costi contenuti;   
     	\end{itemize}
	     
     	\subsubsubsection{Codifica}
        Questa fase ha come scopo normare l'effettiva realizzazione del prodotto software richiesto. In questa fase si concretizza la soluzione architetturale elaborata durante la fase di progettazione, mediante la programmazione vera e propria.    
        Gli sviluppatori, durante la fase di implementazione, dovranno attenersi alle norme di programmazione stabilite in maniera tale da: 
        \begin{itemize}
        	\item ottenere codice leggibile ed uniforme per i programmatori; 
        	\item agevolare le fasi di manutenzione, verifica e validazione
        	\item fornire un prodotto conforme ai requisiti indicati dal proponente; 
        	\item migliorare la qualità del prodotto\ped{\textit{G}}.
    	\end{itemize} 
    
    	\noindent La scrittura del codice dovrà inoltre perseguire gli obiettivi di qualità stabiliti nel documento \textit{\PdQ{} v1.0.0}, in modo da garantire una buona qualità del codice. 
     	\subsubsection*{Stile di codifica}     
       \begin{itemize}
          	\item{\textbf{Indentazione}: i blocchi innestati devono essere correttamente indentati, usando per ciascun livello di indentazione quattro (4) spazi, fatta eccezione per i commenti. Ogni programmatore dovrà configurare adeguatamente il proprio IDE\ped{\textit{G}} al fine di rispettare tale norma;}
			\item{\textbf{Parentesizzazione}: le parentesi di delimitazione dei costrutti vanno inserite in linea e non al di sotto di essi;}
			\item{\textbf{Lunghezza dei metodi}: ove possibile, preferire metodi brevi (poche righe di codice) e che assolvano il minor numero di compiti possibile;}
			\item{\textbf{Univocità dei nomi}: classi, variabili e metodi devono avere un nome univoco ed esplicativo (nome parlante), al fine di evitare ambiguità e consentire ad eventuali lettori di comprendere lo scopo di quel preciso elemento, anche senza conoscenze informatiche pregresse;}
			\item{\textbf{Classi}: le parole componenti i nomi delle classi devono iniziare con la lettera maiuscola (e.g. NomeClasse);}
			\item{\textbf{Costanti}: le costanti devono essere scritte usando solo lettere maiuscole (e.g. COSTANTE). Nel caso siano composte da più parole, queste devono essere separate dal carattere speciale underscore (e.g. NOME\_COSTANTE);}
			\item{\textbf{Metodi}: i nomi dei metodi devono iniziare con una lettera minuscola e, nel caso 	siano composti da più parole, quelle successive devono iniziare con una lettera maiuscola (e.g. nomeMetodo);}
			\item{\textbf{Lingua}: le parti testuali di codice ed i commenti ad esso riferiti devono essere scritti in lingua inglese;}
            \item{\textbf{Ricorsione}: l'uso della ricorsione va evitato quanto più possibile.}
		\end{itemize}
		
		\noindent\textit{Etherless-cli} ed \textit{Etherless-server} saranno scritte in TypeScript sono normate dalla Airbnb JavaScrit Style Guide, il cui uso per TypeScript è implemetnato tramite ESLint. 
		Per quanto riguarda \textit{Etherless-smart}, questo verrà sviluppato in Solidity, seguendo la Style Guide presente nella documentazione ufficiale di Solidity. 
		
	\subsubsection{Metriche} 
		\subsubsubsection{Metriche di analisi dei requisiti}
		\subsubsubsection{Metriche di progettazione}
		\subsubsubsection{Metriche di codifica}                
	
	\subsubsection{Strumenti}
	Di seguito vengono elencati gli strumenti usati dal gruppo durante il processo di sviluppo:
		\subsubsubsection{ESLint}
		ESLint è uno strumento di analisi statica per identificare pattern problematici all'interno di codice JavaScript. Le regole in ESLint sono configurabili; è inoltre possibile descrivere e utilizzare regole personalizzate. ESLint controlla sia la code quality che eventuali problemi riguardanti lo stile di codifica.
		\begin{center}
			\url{https://eslint.org/}
		\end{center}
		
		\subsubsubsection{Draw.io}	
		Per la creazione dei diagrammi dei casi d'uso è stato scelto Draw.io, a causa della sua facile integrazione con Google Drive e velocità e semplicità di creazione dei diagrammi di interesse.  
		\begin{center}
			\url{https://app.diagrams.net/}
		\end{center}
		
		\subsubsubsection{Visual Studio Code}
		Visual Studio Code è l'IDE scelto per la parte di codifica, in particolare tale scelta è dovuta a: 
		\begin{itemize}
			\item completa compatibilità con Windows, Linux e macOs: in questo modo tutti i membri del gruppo possono riferirsi ad un unico strumento senza essere vincolati dal sistema operativo da loro utilizzato; 
			\item supporto per sistemi di debugging; 
			\item integrazione del sistema di versionamento Git; 
			\item numerose estensioni facilmente installabili in grado di coprire la maggior parte delle necessita espresse dal gruppo. 
		\end{itemize} 
		\begin{center}
			\url{https://code.visualstudio.com/}
		\end{center}
	